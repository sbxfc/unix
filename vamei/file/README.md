#文件权限

	 $ls -l mou.md
	 $-rw-r--r--@ 1 sbxfc  staff  5698  2 12  2014 mou.md
	 
- 最开始的-，它表示文件类型，说明mou.md是常规文件(如果是目录文件，则应显示d)。

- 随后有九个字符，为rw-r--r--，它们用于表示文件权限。这九个字符分为三组，rw-, r--, r--，分别对应拥有者(owner)，拥有组(owner group)和所有其他人(other)。第一组表示，如果我的用户身份证明我是该文件的拥有者，那么我就可以对该文件有读取(r)，写入(w)该文件的权限，但不拥有执行(-，如果拥有执行权限，则为x)该文件的权限。第二组表示，如果我的名片上的组身份证明我所在的组是该文件的拥有组的一员，那么我有从该文件读入的权限。第三组表示，如果我的名片显示我既不是拥有者，也不是拥有组的一员，那么我只有读入的权限。

- 后面的1是硬连接(hard link)数目(link count)。

- 之后的sbxfc表示用户sbxfc是文件的拥有者(owner),文件的拥有者有权更改文件权限(比如改为rwxrwxrwx)。而后面的staff表示文件的拥有组是组staff。文件的拥有者和拥有组在文件创建时就附加在文件上(相当于给文件上锁，只有有合适名片的用户才能打开操作)。要注意，超级用户root (也叫做根用户)，该用户拥有所有的文件。

- 随后的5698表示文件大小，单位为字节(byte)。

- 2 12  2014 表示文件的上一次写入的时间(modification time)。实际上在文件附加信息中还包含有文件的上一次读取时间(access time)，没有显示出来。

#链接

当文件出现在一个目录文件中时，我们就把文件接入到文件系统中，我们称建立一个到文件的硬链接(hard link)。一个文件允许出现在多个目录中，这样，它就有多个硬链接。当硬链接的数目(link count)降为0时，文件会被删除。所以很多时候，unlink与remove是一个意思。由于软链接(soft link)的广泛使用(soft link不会影响link count，而且可以跨越文件系统)，现在较少手动建立硬连接。

如果还记得windows系统的快捷方式的话，Linux的软链接(soft link，也叫做symbolic link)就是unix的快捷方式。软链接本质上是一个文件，它的文件类型是symbolic link。在这个文件中，包含有链接指向的文件的绝对路径。当你从这个文件读取数据时，unix会把你导向所指向的文件，然后从那个文件中读取（就好像你双击快捷方式的效果一样）。软链接可以方便的在任何地方建立，并指向任何一个绝对路径。

软链接本身也是一个文件，也可以执行文件所可以进行的操作。当我们对软链接操作时，要注意我们是对软链接本身操作，还是对软链接指向的目标操作。如果是后者，我们就说该操作跟随链接指引(follow the link)。

#umask

当我们创建文件的时候，比如使用touch，它会尝试将新建文件创建为权限666，也就是rw-rw-rw-。但操作系统要参照权限mask来看是否真正将文件创建为666。权限mask表示操作系统不允许设置的权限位，比如说037(----wxrwx)的权限mask意味着不允许设置设置group的wx位和other的rwx位。如果是这个权限mask的话，最终的文件权限是rw-r----- (group的w位和other的rw位被mask)。

我们可以通过

$umask 022

的方式改变权限mask。

#文件操作 

	$touch a.txt

如果a.txt不存在，生成一个新的空文档a.txt。如果a.txt存在，那么只更改该文档的时间信息。(这个命令实际上用得并不广泛，但可以帮我们创建一个空文件来实验下面操作)

	$ls .
	
是list的简写，列出当前目录下的所有文件名

	$ls -l a.txt

列出文件的详细信息

	$cp a.txt b.txt 
	
cp是copy的简写，用来复制文件。在工作目录下，将a.txt复制到文件b.txt

	$cp a.txt ..

将a.txt复制到父目录的a.txt

	$mv a.txt c.txt
	
mv是move的简写，用来移动文件。将a.txt移动成为c.txt (相当于重命名rename)

	$mv c.txt /home/sbxfc
	
将c.txt移动到/home/sbxfc目录

	$rm a.txt
	
rm是remove的缩写，用于删除文件。删除a.txt

	$rm -r /home/sbxfc 
	
删除从/home/sbxfc向下的整个子文件系统。-r表示recursive， 是指重复删除的操作，/home/sbxfc文件夹为空，然后删除/home/sbxfc文件夹本身。

(程序员总是对这个命令很感兴趣,   $rm -rf /   它会删除整个文件树。f的目的是告诉rm放心干，不用再确认了…… 一般情况下，应该没有人会用这个命令。)
	
	$mkdir /home/sbxfc/good
	
创建一个新的目录
	
	$rmdir /home/sbxfc/good

删除一个空的目录
	
	
#文件权限相关

	$chmod 755 a.txt
	
(你必须是文件a.txt的拥有者才能运行此命令。或者以$sudo chmod 755 a.txt的方式，以超级用户的身份运行该命令。)

change mode 改变a.txt的读、写以及执行权限。还记得每个文件都有九位的读写执行权限(参看 Linux文件管理背景知识)，分为三组，分别对应拥有者(owner)，拥有组(owner group)中的用户和所有其他用户(other)。在这里，我们也有三个数字，755，对应三个组。7被分配给拥有者，5被分配给拥有组，最后一个5分配给其它用户。Linux规定: 4为有读取的权利，2为有写入的权利，1为有执行的权利。我们看到的7实际上是4 + 2 + 1，表示拥有者有读、写、执行三项权利。(想想5 意味着什么)

这时，运行$ls -l a.txt, 你应该看到九位的权限变成了rwxr-xr-x。根据自己的需要，你可以用比如444, 744代替755，来让文件有不同的权限。

	$sudo chown root a.txt

change owner 改变文件的拥有者为root用户。这个命令需要有超级用户权限才能执行，所以我们在命令之前加上sudo。

	$sudo chgrp root a.txt
	
change group 改变文件的拥有组为root组

#文件名通配表达式

(wild card, 也叫filename pattern matching)

之前所讲的命令，比如ls, mv, cp都可以接收多个参数，比如:

	$ls -l a.txt b.txt c.txt
	
就可以列出这三个文件的所有信息。

有时候，我们想列出工作目录下所有的以.txt结尾的文件的信息，可以用下面的方式:

	$ls -l *.txt
	
*.txt的写法就运用了通配表达式。它与正则表达式相类似，但语法有所不同。

	Filename Pattern Matching       对应含义 
	*                               任意多个任意字符
	?                               任意一个字符
	[kl]                            字符k或者字符l
	[0-4]                           数字0到4字符中的一个
	[b-e]                           b到e字符中的一个
	[^mnp]                          一个字符，这个字符不是m,n,p



